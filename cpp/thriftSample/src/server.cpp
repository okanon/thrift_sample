// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "sample.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <iostream>
#include <sstream>
#include <winsock.h>
#include <random>

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/lexical_cast.hpp>

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;



std::string doit(int, char**);

class sampleHandler : virtual public sampleIf {
public:
	sampleHandler() {
		// Your initialization goes here
	}

	void hello(std::string& _return, const std::string& value) {
		std::cout << "client->hello(\"" << value << "\")" << std::endl;

		std::stringstream sstr;
		sstr << "Hello " << value << " :)";

		_return = sstr.str();
	}

	void ipaddr(std::string& _return) {
		std::cout << "client->ipaddr()" << std::endl;

		WSAData wsad;
		if (WSAStartup(MAKEWORD(1, 1), &wsad) != 0) {
			sampleException se;
			se.code = ErrorCode::WINSOCK_FAILED;
			se.reason = "Tell the user that we could not find a usable";
			throw se;
		}

		_return = doit(__argc, __argv);

		WSACleanup();
	}

	int32_t random(const int32_t num) {
		std::cout << "client->random(" << 
			boost::lexical_cast<std::string>(num) << ")" << std::endl;

		if (num > 5) {
			sampleException se;
			se.code = ErrorCode::INVALID_NUMERIC;
			se.reason = "Too many digits";
			throw se;
		}

		if (num == 0) {
			sampleException se;
			se.code = ErrorCode::INVALID_NUMERIC;
			se.reason = "Too few digits";
			throw se;
		}

		try {
			std::random_device rnd;
			std::mt19937 mt(rnd());

			std::string retv;
			for (int i = 1; i <= num; i++) {
				retv += boost::lexical_cast<std::string>(9);
			}

			std::uniform_int_distribution<int> rndx(0, boost::lexical_cast<int>(retv));

			return rndx(mt);
		}
		catch (std::exception &e) {
			sampleException se;
			se.code = ErrorCode::GENERATOR_FALIED;
			se.reason = e.what();
			throw se;
		}
	}

	void uuid(std::string& _return) {
		std::cout << "client->uuid()" << std::endl;

		try {
			const boost::uuids::uuid id = boost::uuids::random_generator()();
			_return = boost::lexical_cast<std::string>(id);
		}
		catch (std::exception &e) {
			sampleException se;
			se.code = ErrorCode::GENERATOR_FALIED;
			se.reason = e.what();
			throw se;
		}
	}

	void calculator(Calc& _return, const double num1, const double num2) {
		std::cout << "client->calculator(" <<
			boost::lexical_cast<std::string>(num1) << ", " <<
			boost::lexical_cast<std::string>(num2) << ")" << std::endl;

		if (num1 == 0 && num2 == 0) {
			sampleException se;
			se.code = ErrorCode::INVALID_NUMERIC;
			se.reason = "Too few number";
			throw se;
		}

		_return.plus = num1 + num2;
		_return.minus = num1 - num2;
		_return.multiplies = num1 * num2;
		_return.divides = num1 / num2;
	}

};

std::string doit(int, char**) {
	char ac[80];
	if (gethostname(ac, sizeof(ac)) == SOCKET_ERROR) {
		std::stringstream sstr;
		sstr << "Error " << WSAGetLastError() << " when getting local host name.\n";
		
		sampleException se;
		se.code = ErrorCode::INVALID_IPADDR;
		se.reason = sstr.str();
		throw se;
	}

	struct hostent *phe = gethostbyname(ac);
	if (phe == 0) {
		sampleException se;
		se.code = ErrorCode::INVALID_IPADDR;
		se.reason = "Yow! Bad host lookup";
		throw se;
	}

	struct in_addr addr;
	for (int i = 0; phe->h_addr_list[i] != 0; ++i) {
		memcpy(&addr, phe->h_addr_list[i], sizeof(struct in_addr));
	}

	return std::string(inet_ntoa(addr));
}

int main(int argc, char **argv) {
	int port = 9090;
	stdcxx::shared_ptr<sampleHandler> handler(new sampleHandler());
	stdcxx::shared_ptr<TProcessor> processor(new sampleProcessor(handler));
	stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
	stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
	std::cout << "Starting the server..." << std::endl;
	server.serve();
	return 0;
}

